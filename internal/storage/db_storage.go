package storage

import (
	"context"
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"log"
	"time"

	_ "github.com/jackc/pgx/v5/stdlib"
	"github.com/size12/gophermart/internal/config"
	"github.com/size12/gophermart/internal/models"
	"github.com/theplant/luhn"
)

type DBStorage struct {
	Cfg config.Config
	DB  *sql.DB
}

func NewDBStorage(cfg config.Config) (*DBStorage, error) {
	s := &DBStorage{Cfg: cfg}

	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel()

	DB, err := sql.Open("pgx", cfg.DataBaseURI)

	if err != nil {
		log.Println("Failed open DB:", err)
		return s, err
	}

	_, err = DB.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS users (id INT GENERATED BY DEFAULT AS IDENTITY, login VARCHAR(255), passw VARCHAR(255), cookie VARCHAR(255), balance INT, withdrawn INT)`)
	if err != nil {
		log.Println("Failed create 'users' table:", err)
		return s, err
	}

	_, err = DB.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS orders (userid INT, num BIGINT, stat VARCHAR(255), accrual INT, uploaded TIMESTAMP)`)
	if err != nil {
		log.Println("Failed create 'orders' table:", err)
		return s, err
	}

	_, err = DB.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS withdrawals (userid INT, num  BIGINT, amount INT, processed TIMESTAMP)`)
	if err != nil {
		log.Println("Failed create 'withdrawals' table:", err)
		return s, err
	}

	s.DB = DB

	return s, nil
}

func (s *DBStorage) GetUser(ctx context.Context, search, value string) (models.User, error) {
	ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	user := models.User{}

	var row *sql.Row

	switch search {
	case "cookie":
		query := `SELECT * FROM users WHERE cookie = $1`
		row = s.DB.QueryRowContext(ctx, query, value)
	case "login":
		query := `SELECT * FROM users WHERE login = $1`
		row = s.DB.QueryRowContext(ctx, query, value)
	}

	switch err := row.Scan(&user.ID, &user.Login, &user.Password, &user.Cookie, &user.Balance, &user.Withdrawn); err {
	case sql.ErrNoRows:
		return user, ErrNotFound
	case nil:
		return user, nil
	default:
		log.Println("Failed get user:", err)
		return user, err
	}
}

func (s *DBStorage) AddUser(ctx context.Context, user models.User) (string, error) {
	ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	_, err := s.GetUser(ctx, "login", user.Login)
	if err == nil {
		return "", ErrLoginExists
	}

	userCookie, err := GenerateCookie()
	if err != nil {
		return "", err
	}

	h := sha256.New()
	h.Write([]byte(user.Login + user.Password))
	hash := hex.EncodeToString(h.Sum(nil))

	_, err = s.DB.ExecContext(ctx, `INSERT INTO users (login, passw, cookie, balance, withdrawn) VALUES ($1, $2, $3, $4, $5)`, user.Login, hash, userCookie, 0, 0)

	if err != nil {
		log.Println("Failed added new user to DB:", err)
		return "", err
	}

	return userCookie, nil
}

func (s *DBStorage) Withdraw(ctx context.Context, user models.User, withdrawal models.Withdraw) error {
	ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	if !luhn.Valid(withdrawal.Order) {
		return ErrBadOrderNum
	}

	if user.Balance < withdrawal.Sum {
		return ErrNoMoney
	}

	user.Balance -= withdrawal.Sum
	user.Withdrawn += withdrawal.Sum

	_, err := s.DB.ExecContext(ctx, `UPDATE users SET balance = $1 WHERE id = $2`, user.Balance, user.ID)

	if err != nil {
		log.Println("Failed update balance after withdraw:", err)
		return err
	}

	_, err = s.DB.ExecContext(ctx, `UPDATE users SET withdrawn = $1 WHERE id = $2`, user.Withdrawn, user.ID)

	if err != nil {
		log.Println("Failed update withdrawn after withdraw:", err)
		return err
	}

	_, err = s.DB.ExecContext(ctx, `INSERT INTO withdrawals (userid, num, amount, processed) VALUES ($1, $2, $3, $4)`, user.ID, withdrawal.Order, withdrawal.Sum, time.Now())

	if err != nil {
		log.Println("Failed insert withdrawal into withdrawals:", err)
		return err
	}

	return nil
}

func (s *DBStorage) WithdrawalHistory(ctx context.Context, user models.User) ([]models.Withdraw, error) {
	var withdrawals []models.Withdraw

	ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	rows, err := s.DB.QueryContext(ctx, "SELECT num, amount, processed FROM withdrawals WHERE userid = $1 ORDER BY processed DESC ", user.ID)

	if err != nil {
		log.Println("Can't get withdrawals history from DB:", err)
		return withdrawals, err
	}

	for rows.Next() {
		withdrawal := models.Withdraw{}
		err := rows.Scan(&withdrawal.Order, &withdrawal.Sum, &withdrawal.Time)
		if err != nil {
			log.Println("Error while scanning rows:", err)
			return withdrawals, err
		}
		withdrawals = append(withdrawals, withdrawal)
	}

	if err := rows.Err(); err != nil {
		log.Println("Rows error:", err)
		return withdrawals, err
	}

	return withdrawals, nil
}

func (s *DBStorage) AddOrder(ctx context.Context, order models.Order) error {
	ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	if !luhn.Valid(order.Number) {
		return ErrBadOrderNum
	}

	row := s.DB.QueryRowContext(ctx, `SELECT userid FROM orders WHERE num = $1 LIMIT 1`, order.Number)

	orderDB := models.Order{}

	err := row.Scan(&orderDB.UserID)

	if err == nil {
		if orderDB.UserID == order.UserID {
			return ErrAlreadyLoaded
		} else {
			return ErrLoadedByOtherUser
		}
	}

	_, err = s.DB.ExecContext(ctx, `INSERT INTO orders (userid, num, stat, accrual, uploaded) VALUES ($1, $2, $3, $4, $5)`, order.UserID, order.Number, "NEW", 0, time.Now())

	if err != nil {
		log.Println("Failed insert new order into orders:", err)
		return err
	}

	return nil
}

func (s *DBStorage) OrdersHistory(ctx context.Context, user models.User) ([]models.Order, error) {
	var orders []models.Order

	ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()

	rows, err := s.DB.QueryContext(ctx, "SELECT num, stat, accrual, uploaded FROM orders WHERE userid = $1 ORDER BY uploaded DESC ", user.ID)

	if err != nil {
		log.Println("Can't get withdrawals history from DB:", err)
		return orders, err
	}

	for rows.Next() {
		order := models.Order{}
		err := rows.Scan(&order.Number, &order.Status, &order.Accrual, &order.EventTime)
		if err != nil {
			log.Println("Error while scanning rows:", err)
			return orders, err
		}
		orders = append(orders, order)
	}

	if err := rows.Err(); err != nil {
		log.Println("Rows error:", err)
		return orders, err
	}

	return orders, nil
}
